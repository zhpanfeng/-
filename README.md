-多玩家游戏编程概述
 目录：
一、	高层架构
1.	Client/Server
2.	Peer to Peer
3.	Hybrid(杂和)
4.	示例：纯Client/Server
5.	示例：纯Peer-to-Peer
6.	示例：杂和模型
7.	Client端预测
二、	低层架构
1.	TCP vs.UDP
2.	BSD Sockets 和 WinSock
3.	UDP 概念
无连接
不可靠
4.	数据报协议
5.	地址和端口
6.	选择一个端口
7.	使用UDP
8.	发送数据(隐含目标地址)
9.	接收数据
10.	阻塞与非阻塞I/O
11.	使用多少个端口
12.	UDP + TCP
13.	网络地址转换(NAT)
14.	可靠有序发送
15.	连接质量
16.	化零为整(把数据整理为大包)
17.	分片和组装
18.	轮询 vs. 多线程
19.	压缩和带宽管理
20.	安全和加密
作弊
加密
21.	跨平台问题
22.	总结
23.	贡献者
24.	推荐读物
后记：
国内介绍多玩家游戏开发的文章比较少，我第一次读到此文章时，决心把它翻译成中文，方便中文不好的网友。
原文章地址：
http://trac.bookofhook.com/bookofhook/trac.cgi/wiki/IntroductionToMultiplayerGameProgramming

断断续续用了将近四天的时间，才完成整篇文章的翻译。Word显示，整篇文章(包括标点在内)有一万一千多的字数。重新阅读自己翻译的文字，有许多地方是直译，句子还不通顺。虽不满意，但没有重新整理一遍的耐心，或许以后会有心情重新整理一下，以后再看吧。
如果说我的翻译一无是处的话，我觉得至少在排版上做得比原文好。
有时候，你觉得做某个事情很有意义，你信心十足，万丈豪情。可是到最后，你发现：离你的想象差很远，你感觉不是你想要的结果，没有了当初的那份激情，也开始怀疑做这件事情的意义。
  我想那些厉害的人，应该就是那些对做一件事情始终充满激情并且没有怀疑的人吧。
 说点高兴的事情，翻译这篇文章的收获：以前没有想过或者说意识到：系统开放一个端口进行通信也是要消耗系统资源的！
  原文章如果直接，应该译为“多玩家游戏编程入门”，国人一般不会这样称呼，我直接译为“网络游戏开发入门”或“网游开发入门”，这样被搜索到的可能性或许更大吧。

=多玩家游戏编程概述
  以下简称“编程”
  编程的一个方面是涉及的方面和各个方面如何彼此联系。各个方面都要处理到，从高层的游戏特定任务到低层的类似于网络包广播和接收。
   高层架构
   在进入实现一个多玩家游戏的细枝末节之前，先后退一步从大局来思考我们做的事情。“发送比特”与“发送哪个比特”不同，后者之后处理。
  比如，两个玩家正在激战，不能出现说，玩家A认为他把玩家B给灭了，而玩家B却认为他把玩家A给灭了。
   最常见结构是C/S 架构和P2P架构。C/S比P2P概念简单且容易实现，我们先讲client-ser er模式。
Client/Server
   在架构里，所有玩家或者说client，连接到一个中心机器server。server对所有重要决定，状态管理和广播信息到单独的client负责。
   因此，server在带宽和计算方面成为瓶颈。server必须全权负责发送任务到所有的玩家。server不得不发送和接收N个独立的流数据，所以它的网络连接负担也很重。
	有时server会作为“本地server”或者”监听server”运行在玩家的机器上。在这种情况下，规则仍然适用，因为client和server逻辑上是无关的即便它们运行在一个物理系统上。

Peer to Peer
P2P系统把计算任务分派给所有的玩家。如果有8个玩家，使用每台电脑，充分发挥所有计算机性能。缺点是，“计算”意味着“做出决定”，作弊可能变得方便（每个client可能被hack，来达到对特定玩家有利）。另外，因为每个peer必须基于其他peer提供的数据来保证它广播的“决定”，一致性的错误更容易影响系统。如果一个peer掉线或者在一个规定时间内没有获得正确的信息，类似于在一个多处理器电脑中一个CPU发生故障的同步失败会发生。
peer-to-peer server的优势在于对于每个系统全部的带宽和计算的要求减少，不需要一个单个强大的server为管理整个游戏负责。
杂合
实际中，大多数是杂合架构作为极端在每个方向上都可能导致严重的问题。
在一个真实的client-server系统中，client不应该移动角色直到server返回“基于你的上一次输入，这里你的新位置”回应。假如你有client-side预测(之后讨论)，但是这同样意味着server负责处理所有的碰撞检测。这种大密码计算负担，对于大世界来说已经到达不能承受的程度。
一个妥协是允许client管理它们自己角色的运动，之后它们轮流向server提交自己位置的报告(对于提交的运动，server要做一些基本的常规检查)。这样既使用了每个client的计算能力又减轻了server的巨大的负担。由于client对于一些事情(比如位置)被授权，作弊的机会增加。
示例：纯 Clietn/Server
  到处是纯client-server实现，一般不会认为特别高级或有诱惑力。认识纯client-server模型的最好的方式是每个client是一个哑终端(dumb terminal)---它能做的只是传输玩家输入给server然后报告server消息给玩家。
  标准文本MUD(multi-user dungeon)是经典的纯client-server结构。实际上，使用telnet最简单的终端你能玩许多MUD。
   server主循环如下：
   while not done
     for each player in world
  		if input exists
  			get player command
			excute player command
		tell player of the results
	simulate the world
broadcast to all players
client主循环更像下面：
  while not done
   if player has typed any text
		send typed text to servers
  if output from server exists
   print output
注意client不参与模拟—它仅是处理输入与输出，事实上一点也不需要了解游戏。
示例：纯 Peer to Peer
现在看一下典型的peer to peer 结构。想象一个玩家可以竞争的坦克游戏。如果此游戏为peer –to-peer,每个玩家管理他的坦克位置和状态，并且负责决定是否撞到其他坦克。
因为是peer-to-peer，没有server主循环，只有client主循环，可能如下：
while no done
		collect player input
		collect network input about other players
		simulate player
			update player’s state if informed it’s been hit
			move player
			update other player state (ammo, armor, etc.)
    report player state to other clients
 
   如果你处理过作弊者，上面的alarm bell应该关闭。特别的，因为client负责模拟，模拟相关的项目都可能作弊。
如果被击中，第一步是更新更新玩家的状态.对于一个hacker来说，简单地忽略进入的“损害包(damage packets)”相当容易(可以通过修补client程序甚至构造(hooking up)一个包过滤器来监视进入的网络流量)。
第二步是通知其他client它们被击中了。每帧告诉每个client它们被击中是相对不重要的。因为其他client信任你的client，它们会做职责的事情和接受损害。
第三步比较简单，即运动。client负责角色的状态，可以修改client来达到以任意的速度来移动角色甚至瞬间移动到任意的位置(“超时空”)
最后，甚至世界也可以被破解。无限的弹药，无限的装甲，无限的能力提升甚至基本的得分。
关键问题是client有许多作弊的机会，因为每个client决定许多世界发生什么。一个client-server架构也会有作弊的风险，但是需要积极地参与server操作或者通过模拟一个完美的角色(瞄准机器人)或者提供一个角色或者提供一个角色名义上无法达到的数据(heads up displays,雷达)。
通用规则，peer-to-peer架构对于阻止作弊者和破解更困难。
当然，没有server使一些事情简单起来，没有单个机器要求模拟整个世界。网络带宽对于每个单独机器变得糟糕起来因为他们不得不直接与其他机器直接通信，但是没有被视作一个单个server的集中的网络带宽。
示例：Hybrid Model
一个杂合的系统综合了client-server和peer-to-peer架构的各个方面。主要目的是减轻client的一个负载，每个client轮流负责响应(不用等待server更新)。server的工作负担也会减少。
比如，一个大规模多玩家游戏(massively multiplayer game)可能这样设置：server负责管理战斗和角色数据，但client负责角色运动。因为运动可能消耗许多CPU周期，这样可以减轻server的工作负担，与此同时，在client部分允许平滑的运动。当然，这些很容易被破解，比如最臭名昭著的“速度破解”
client端预测
如果server(或者另一个peer)负责管理世界，当它们广播新的状态信息给client时会有显著的时延发生。时延会成为冲突，在某些情况下，完全不现实。
例如，在第一人称射击游戏中，为了本地展示这些改变，让client发送“准备视角改变”(即移动鼠标)之后等待server的一个响应，是不可能的。
通常会假设许多不同的动作或者朝向改变被传递给之后被server返回。之后，如果server决定不允许此动作，你回退更正。
当你在一个世界中跑动并且想要平滑移动时，对于动作尤其重要。能够预测动作相当准确，只有在异常情况下才会被纠正。另外，可能通过逐渐地更正而不是突然改变，减少（这里翻译不下去了）
低层架构
  现在已经分清高层不同类型的构架，需要弄清楚如何处理低层通信架构。高层架构决定不同的电脑和游戏的不同元素彼此如何通信，更重要的是，哪个组件负责仲裁和作决定。
  低层的网络层不关心这些。它只关心数据打包和跨网络发送(相反的，从其他机器接收数据)。
  在过去，有许多不同的私人拥有的网络传输层。Novell有IPX/SPX;微软有NetBEUI;苹果有AppleTalk;许多其他公司有它们自己的私有系统。到20世纪90年代，TCP/IP(Transport Control Protocol/Internet Protocol)协议作为低层网络层最终胜出。
  有许多描述TCP/IP的不错的书和网页，OSI 网络栈，和许多不直接与此处的讨论相关的细节。对于我们，TCP/IP作为网络层选择就能满足。如果基于某个奇怪的原因，在1995年左右，你卡在了time warp，必须要支持LAN玩法，你得要研究一下Novell的IPX/SPX协议在DOS下的支持。如果你没有被time warp卡住，在可以预见的未来，TCP/IP是你需要关注的仅有的协议。
TCP vs. UDP
   TCP/IP是一个基于IP协议包含TCP和IP还有一组协议(TCP,UDP和ICMP)的涵盖性术语。和我们相关的部分是TCP和UDP协议，通过IP协议为包(packet)的关联。
  Transmission Control Protocol,或者TCP，是一个高层(对应用而言)、面向连接的，可靠的，包有序的发送系统。意味着它逻辑上认为一个机器连接到另一个，两者之间任何的流量被确保到达的同时确保有序到达。另外，TCP是一个流协议(stream protocol)，不同的包不会被区分，取而代之的是一个从源到目的地被推送的不断的流数据 (下面仍然是包，但对于应用来说它看起来像一个byte流)
  User Datagram Protocol,或者UDP,与TCP比起来更初级的特征集。是无连接的，不可靠的数据报协议。电脑彼此发送可能到达也可能无法到达目的地的包，可能按照发送的顺序到达也可能不是按照发送的顺序到达。向外发包也可能有实现的大小限制。
   从结构上来讲，TCP和UDP是兄弟协议，因为它们都基于IP层，但对于程序员来说，因为相对于TCP来说，因为它提供了一个更小的特性，UDP是更低级的协议。
  基于这个理由，TCP比UDP更方便，但是方便是有代价的。与UDP比起来，TCP性能更低，因为数据传输时产生的密集的错误检测，握手，拥塞管理和确认。使用TCP ，即便你接收到一个包，内核/栈会持有此包直到所有以前的包到达—这意味着在最新的信息可用之前，直到TCP栈决定你可以使用之前，你的代码一直看不到。在丢包的情况下，可能引入3秒重新发送定时器。
   不要尝试使用TCP，在实时游戏中，最后总会导致心碎。无数的网络游戏曾经尝试基于TCP最终换成了UDP—之后总会很痛苦。
  基于以下原因，UDP是网络传输的选择。在TCP提供的功能之上，我们不得不实现许多功能，但是通过这样做我们可以定制性能和功能依照我们的设想。
BSD Sockets 和WinSock
好，已经决定使用UDP协议，但是如何使用？大部分现代操作系统提供系统级层面特性通过API(Application Programming Interface)。 例如常用的API包括OpenGL；DirectX,GDI和Win32(在Microsoft Windows);在Macintosh系统是Carbon.
 基于我们的目的，使用socket 网络API,也即“BSD socket”。BSD socket API在80年代那时被开发用来提供一个合理的可移植的访问不同的Unix风格的TCP/IP子系统(或者栈)的方法，一个变体，Winsock最终为Windows开发出来。
  功能方面，WinSock与BSD socket极其相似。事实上，在一些windows代码周围用一些合适的定义和#ifdefs，代码可以共用。WinSock和BSD socket之间有些区别，通常很小，从总体上来说，对于大部分程序员来说，没有大问题。
 UDP概念
正如前面提到的，UDP是无连接不可靠的数据报协议。让我们将问题分解一下看看需要解决哪些问题。

 无连接
    UDP没有“连接”的概念。一个电脑不连接到另一台电脑---通信不需要建立也不需要接续一段时间。通信一次发送一个数据包或者数据报。就像给某人邮寄邮件，在每个信封上写上地址然后邮寄。
 不可靠
   不像TCP，UDP不能确保一个电脑发送的包一定到达另一个电脑。另外，UDP不确保任接收的何包以发送的顺序到达。你可以想象，有些不方便，大部分游戏或者实现一个可靠的按顺序的传输机制在UDP之上或者保证他们的高层协议不需要可靠、有序的数据。
 数据报(Datagram)协议
   UDP通过发送离散大小的数据包或者数据报来实现。不同于面向流的比如TCP协议，一次发送一个byte的数据，让接收者解析byte stream。合适的包大小取决于不同的因素，但一个好的，大概的数据对于大部分人来说是1400byte，因为比一个典型的Ethernet MTU(Maximum Transmission Unit)小一点。
 Address and Ports(地址与端口)
   UDP包被发送到一个由IP地址和一个端口号(16-bit无符号数值)组成的目的地址。为了接收数据，目的地系统必须在此端口监听(之后讨论)。
 选择一个端口
   端口值被划分为三个范围：系统端口(Well-Known)Ports(0 到1023);用户/临时(注册)端口(1024到14151); 动态/私有端口(49152到65535)。
   一个应用程序不应该使用分配给系统端口范围内的端口号数字。动态/私有端口,但是不能指望特定端口一定可用。
 像大多数那样做，在User Port范围内选择一个端口然后声称为自己的。这种机会极小，应该允许端口值被覆盖或者由用户指定。
   使用UDP
     我虽然想，但是时间不允许我实现一个UDP库。有许多关于实现socket和WinSock使用的信息，因为当谈到UDP的使用时你不会困惑不解。看一下UDP编程的参考书目引用。
我强烈建议使用ENet开源UDP网络库。它解决了大部分UDP层具体细节的问题，使程序员将精力关注在更高层，特定游戏架构上面。
 在socket API之下，所有的通信通过一个使用socket()系统调用分配的socket 对象(socket object)。socket被用来发送和接收数据。一旦分配一个socket，你可以使用sendto() API发送数据给一个明确的IP地址和端口的组合:
int sendto (SOCKET s,
		const char *buf,
		int len,
		int flags,
		const struct sockaddr *to,
		int tolen);
  第一个参数是前面使用socket()调用分配的socket,第二个参数是一个指针，指向要发送数据的缓存(buffer of data).第三个参数指定buf中byte的数目。flags参数指定和这个调用相关的标记。to结构目标地址，tolen是to缓存(to buffer)的大小。
   这里变得有些难看了。特别是，整个sockaddr情况是一个类型转换的噩梦，但一旦你想清楚，就不太麻烦。
在UDP，目标地址由一个称为sockaddr_in的特殊结构定义。WinSock下，如下：
  struct sockaddr_in{
			short sin_family;
			u_short sin_port;
			struct in_addr sin_addr;
			char sin_zero[8];
};
   为了使用sendto()正确发送数据块到目标地址，需要填写合适的值。将sin_family设置为AF_INET.
sin_addr有些难以理解。它需要一个网络字节序(大端(big endian))网络地址。获得网络地址的最简单的办法是传递一个代表标准IP地址(如“192.168.1.100”)的字符串给socket函数inet_addr()。这样就会返回一个合适格式化值替代sockaddr_in中的结构。
注意：inet_addr()不支持域名查询(即将”foo.example.com”转换为一个IP地址)，它只处理“点”格式的数字地址。如果你的应用需要同时支持点和名称IP地址，如果inet_addr()失败最容易的办法是使用gethostbyname():

最终需要指定目标端口。这个也要用网络字节序格式，使用助手函数htons()(host-to-network-short)来从host到network格式转换。
好的，为了填写sockaddr_in结构，放到一个代码片段里：

糟糕，工作量太大了。让我们看看给某个地址发送一个缓存大体是怎样的：


   发送数据(隐式目的地)
     上面的代码段展示如何发送数据到一个明确的目的地。使用bind()调用函数可以绑定socket到一个特定的地址，你可以发送数据到一个不明确的地址。如果已经绑定，不用每次指定一个明确的目标地址，可以用send() API发送数据。看起来像你连接到了目标地址，但是别被蒙蔽，实际上不是，你只是告诉你的本地socket，你的目标地址未来不再明确指定。
   接收数据
    在某个socket上通过调用recv()或者recvfrom()来接收数据。两个API操作相同，除了recvfrom()会告诉你包的源地址。当你不知道包从哪里来，你想回应时，就变得很方便。
阻塞vs.非阻塞I/O
  默认情况下，大部分socket实现是“阻塞的”。这意味着当被要求做某事情时，它们会等待直到它们完成做某事。这对游戏不好(除非你将你的网络模块放在一个单独的线程里，此处不涉及，作为一个通用规则，我不推荐)因为你可能调用一个socket函数之后会hang一段时间(hang for an indeterminate period of time)。
   Windows和BSD socket在开启与关闭非阻塞IO方面稍微不同。
  WinSock 调用ioctlsocket():
  //enable non-blocking IO
  arg = 1;
  ioctlsocket(s, FIONBIO, &arg);
在BSD socket你通过一个稍微更迂回的方式：
   fcntl(s, F_SETFL, O_NONBLOCK | fcntl(s, F_GETFL));
一些类Unix的操作系统没有fcntl()接口，在这些操作系统上，你不得不用ioctr(),与WinSock接口有些像：
   arg = 1;
   ioctl(s, FIONIO, &arg);
  socket不再阻塞，如果没有数据等待，在recv[from]()中将会返回一个“软”错误。检测这个条件而不是仅仅将其捕获为一个错误是很重要的。
   int err, result;
   char buf[2048];
   while(1)
  {
result = recv( s, buf, sizeof(buf), 0);
if( result == SOCKET_ERROR)
 {
   err = errno; /* under Windows use WSGetLastError() */
   if(err == EAGAIN) /* WSAWOULDBLOCK on Windows */
   {
 /* no data waiting, not really an error */
  sleep(10); //or break, or whatever
}
     else
     {
       /* a real error occurred! */
}
}
	  else
     {
       /* do something with data returned from recv() */
       /* should have ‘result’ number of bytes in buf */
}
}
使用多少个端口
  一个应用可以分配许多端口，常见问题是：我应该使用多少个端口？没有定论，但是可以分解为以下几个：
  使用多个端口可以简化复用进入的包。比如，你可以为每个client分配一个端口，然后假设某个端口所有进入的流量来自于一个client。或者你也可以用一个专用端口来“控制”数据另一个端口来“标示状态”数据等等。这能适当地简化问题，但是以创建和维护许多端口为代价。你仍然不得不验证每个包的有效性，不管怎样，你需要进行包检测，手动复用不会消耗太多。
  在操作系统中每个端口有它自己的缓冲组。因此，如果发现许多网络流量，简单地使用更多的端口比获得更多的缓冲空间更合理。
   你使用的端口越多，与另一个服务使用端口发生冲突的可能性也越大。你还需要用掉更多的系统资源，还要在防火墙或NAT box上打开/转发更多的端口。
   最简单的选择是使用单一端口且复用包基于它们的源地址和负载(source address and /or payload)。
UDP + TCP
  经常被问到的一个问题是：为什么不使用UDP作为不可靠的数据，TCP作为可靠的数据？初看起来像一个绝妙的点子，在实际中不成立。在不稳定的网络连接中TCP所显示的性能特性从UDP流量来说，将会搞砸。意味着两种不同的流可能彼此不同步。在游戏中经常产生古怪的问题。
  只使用一个比UDP可靠的系统比如ENet并且丢弃TCP.
网络地址转换(NAT)
对于商业和个人来说，独立IP地址的也是有限的。“网络地址转换”，也即NAT成为一种流行。
NAT的原理很简单---它接受单个公网IP地址然后复用它成为许多内部电脑的私有IP地址。通过快速地记录进出的流量和合适的地址转换来完成。虽然概念上简单，当涉及到游戏时，确实有一些弊端。
我不会谈论太多关于NAT工作的细节，因为在网上有许多这方面的文章。我大概解释一下它是如何影响一个多玩家游戏的。
  第一个，最明显的问题是，一个在NAT之后的游戏主机需要监听端口来转发。这是很标准的东西，没有什么玄机。只要确保NAT或者防火墙之后的server知道如何配制它们的网络来转发server端口的流量。在一个peer-to-peer系统里，每个玩家的机器也必须有一个端口开放来接收流量。
  第二个问题是一个游戏不能假设从一个单个IP地址来的数据流量来自于同一个电脑(因为公用IP可能被多个电脑共用)。游戏必须检测进入包的源地址包括端口来决定哪个client在发送数据。
  第三个问题一个比较少见的问题，但是基于这个原因是隐藏的，一些路由器和NAT会动态地改变它们发送端口。UDP是无连接的协议，对它们来说，没有理由不这样做，但实际上是很多开发者依赖于一个玩家的初始IP：在游戏期间，端口源地址将会保持一样。不幸的是，不是这样的。
  如果一个游戏server绑定client信息到一个源地址时，就会产生问题。
比如，Biff尝试连接到游戏server.它的源地址(通过NAT)可能是76.54.32.10：4567.游戏说：好，可以。我们知道Biff总是76.54.32.10：4567.
  下一次你接收到一个来自那个地址的包，你知道它来自于Biff因为你已经逻辑上将Biff和那个地址绑定。
  现在Charlie连接到你的游戏，他和Biff一样在同一个NAT之后。它的地址是76.54.32.10：6789(提示：因为他们通过NAT共用同一个IP，故他们有相同的IP地址)。再一次，没有问题，因为他们两个端口不一样，我们依然像之前一样处理。
  但基于一些奇怪的理由，NAT决定翻译Biff的地址用稍微不一样的方式。突然它决定Biff的地址是76.54.32.10:9876.在无连接的协议，这是可行的，因为在理论上，一个基于UDP的server不理解一个“连接”标记的client，所有进入的UDP包预计通过源地址由recvfrom()被回应。不幸的是，游戏不是这样工作的。
   如果你的游戏server获得一个奇怪的请求从76.54.32.10:9876,一个没有映射到任何已知client的源地址就会出现一个错误条件(an error condition).不仅如此，突然间Biff好像没有连接了。
   检测这种情况是相当痛苦的，会导致噩梦般的支持问题。在没有任何明显的理由情况下，
有一小部分玩家抱怨间歇地断开连接。
解决此问题的一个方法是避免基于源地址端口值持续地处理包数据。而是，每个client应该发送一个统一的不同的client ID用来区分在同一个IP地址上不同的多个client。我使用基于client的私有IP地址的低两个byte的16-bit统一标识符(unique identifier).比如，192.168.1.10能够保证生成一个特殊的(1 << 8)|10,或者0x010A的 client ID。
注意：在大部分情况(家庭或者小的企业),你只需要使用最低byte，但是有大的(two-byte)私有IP范围的大的网络可能产生潜在的源冲突。比如，如何Biff在192.168.1.66，Charlie在192.168.2.66，一个只看低顺序byte的系统就不能够区分两个client了。
加密注意：如果进入的包是session key加密,因为不能解密，故你不能加密client ID。在这种情况下，你需要有一个结构体，一个怎样的结构体呢？第一个16bit是明文和client ID在一起，可以被用来查找client的session key,用来轮流解密数据的余下的部分。
可靠有序发送(Reliable In-Order Delivery)
   假设你不使用ENet而打算自己实现一个可靠的，顺序的协议。我简要描述一下如何实现。
   第一是要用一个顺序数字标记你的发送的包。随着跨越线路发送到特定的目标的包数量不断地增加，这个数字也不断地增加。
   当一个包被可靠发送时，模拟包上的头(带有顺序编号)，把这些包存储在一个某处的缓存里。当包到达目标时，接收者需要发送一个确认给发送者说“我接收到了包XYZ”(现实是这样做很低效，实际要做的是仅发回你接收的“最近有序的包”，对于其他数据特别珍惜)。
   发送者接到确认之前，它会周期性地重新发送那个包。当确认到达，即将发出的包的拷贝从缓存中删除。
   很简单，但是不考虑有序发送的问题。序列数字为你处理这个问题。当接收者收到一个新包，它仅将序列号与从源地址接收到的上一个包的序列号进行比较，如果序列号小于或者等于上一个，就忽略掉。
   如果新到的包序列等于下一个期望的序列号(上一个序列+1)，这个包被接受之后发送者被通知包已经安全到达。
   如果新到的包顺序比预期的顺序编号大，可以采取两个办法。最简单的方式是忽略它然后等待server的重发，但是这样做很低效。缓存这个包一段时间，期望可能的高等级的包(the necessary prior packet)最终出现。当出现时，可以从buffer中释放出新包，从而最小化一个包丢失所能造成的延迟。
   
连接质量
   玩家对于一个特定server的连接质量，是他们想要知道的一个方面。这通常会被量化为延时和丢包率。
   延时是从一个特定的client到一个server所需要的时间。长延时意味着响应慢。丢包率被表示为在client和server之间包被丢弃的百分比，因为数据不得不重新发送，在游戏时会产生卡顿现象。
   测量延时挺麻烦的。在每个发送的包上，将包的发送时间作为头的一部分嵌入进去。当收到包时，接收者将返回时间作为确认发回，当发送者接到确认，它可以查看发送时间然后与时钟进行比对来知道一个来回需要多长的时间。
   这要求每个包有更多的数据(时间戳)，所以有些人更喜欢用ping命令每秒来测量此时的延时。
   丢包率可以有几种不同的方式，大多数很 选择一个方法(无序包接收的百分比，请求重发的数目，等等)然后持续。
整理数据成为大的包(Collating Data into Large Packets)
   每个发出的UDP包被22byte的私有UDP头阻碍(在传输层被阻塞)用来告诉在它和它的目标地址的每一个它要去哪里以及它的大小。对于每个包来说，是相当大的一个数据段。
   早期的优化是整理包成为大的包为了达到为一直发送这些头。它们通常整理为理想的传输大小，这个大小会改变，凭经验来说，大概在1400byte左右。
   你不想组装太长，因为，比如每100ms.其他要考虑的是使用modem连接的用户可能觉得1400byte的包广播起来已经太长了(@56k，33k可用的速度，在最佳的情况下，传输一个1400byte要用时300ms).如果modem连接很重要，为了减少延迟，一个小点的buffer 大小比如500byte更合适。
分片和重新组装(Fragmentation and Reassembly)
   相对应的问题是：如何组装小的、效率低下的包成为大的包来适应1400 byte的理想MTU大小。作为一个惯例，提到包分版和重新组装不错，可以使得应用程序员的生活明显更轻松。
如何实现取决于你，但一个探索方向是在头文件中有子顺序(sub-sequence)数字，用来表明包是否是一个大包的一部分。当一个接收者看到这些，它就会知道如何处理这些包然后重新组装这些数据当这些数据以段(in fragments)的形成到达时。
轮询(polling)vs.多线程(Multithreaded)
需要周期性地调用网络模块，原因如下：1.为了确保数据发送的可靠性，数据有时需要被重发；2.想要知道是否有新的数据到来，才能返回接收确认。
每隔N毫秒调用一下网络模块，比如在游戏主循环之中。这是最简单的方式，事实上也是我在大部分情况下建议的方式，如果游戏中出现一个不可预测的突然消耗长时间(比如从硬盘同步加载大的资源),有成为瓶颈的可能。(解决办法：不仅会影响你的网络模块调用，能够在游戏循环中不要加入任何能够导致延长系统周期的操作，因为它不仅仅会影响你的网络模块的调用)。
   使你的网络代码运行在一个单独的线程里，更复杂，但是可以更好地预测时间。为了推迟对新的事件的处理，可以sleep()或者阻塞，不会受主循环的影响.设计一个好的“锁系统”是非常重要的，因为你要与竞态与死锁做斗争。这其中的复杂性不容小觑，只有当你充分意识到你在做什么的时候再选择这个方向。大部分情况下，每帧调用一下你的网络模块就挺好的。

压缩与带宽管理
     不管是client端还是server端，网络带宽很快会被消耗殆尽. 因此，数据压缩很重要。
     从大局来说，你的首要任务是最小化你需要发送的数据。在确定任何消耗资源的压缩计划之前，确保只接收client需要的数据。如果你有一个大的世界， 把所有实体的状态广播给所有client是不可取的--带宽使用会超出想象。 每个client应该有一个特定的"感兴趣区域(area of interst)"和一些通用  状态，这是server广播给client的所有信息。 在忧郁地牢同半兽人做战的玩家不需要接收六千里地之外幸福旅馆店主和主顾的对话信息。
     一旦你确定必须被传递的相关信息子集，你会想在网络库接收到来自网线上的实际数据之前先进行压缩。这意味着截取没有必要那么大的数值等。比如，如果不需要浮点型位置信息，16位固定值能接受就用。如果能接受8位角度信息，那么就发送bytes来代表。如果有多个比特标志，试着把它们一起放在不使用的包头文件之中。
截断与压缩应该有不错的效率，至少25-50%。下一步是压缩包中的数据。下一步是压缩包(packet)中的数据。不参与具体细节的讨论，只说有许多关于数据压缩的介绍。
   第三步你将要采取的是delta压缩，或者发送改变而不是绝对状态。比如，假如你发送12byte的数据来代表位置信息。如果你每帧都这样做，即便角色不移动，这是天大的浪费！当角色位置改变时,再广播位置更有效。接受这一观念并且把它扩展到整个状态模块，这是delat压缩给你的启示。
delta压缩通过以下方式实现：保存一份本地状态的拷贝和上次被其它机器成功
接收的状态，只发送改变的值并且通过delta标志头来标明哪些值被发送。
安全与加密
连网游戏不得不解决的一个最大的问题是作弊与安全。一个人作弊就可以
毁掉成千上万玩家的游戏。
  作弊
当玩家拥有他们不应该拥有的信息时，作弊就会发生。更糟糕的是，因为他们的client在某些区是权威的，他们可能改变游戏中的事件。
  某些人最容易的破解办法是获得表面上有限的信息。此种方法利用以下事实：许多游戏发送比client需要知道的更多的信息，让client合适地过滤这些信息。
   比如，一些玩家角色可能是隐身的。这些信息可能以“实体X不可见，所以不要绘制它”来发送到client。通过破解或者修改client，作弊者能够简单地说“忽略不可见标记”来知道不可见的角色在哪里。
  玩家也可能使用可用的信息来建立client端助手或者bot(机器人)比如，一个角色的朝向经常不会不断地发送到server(因为它改变的太频繁),server必须确保玩家的client有角色整个周围区域全部的相关信息.在这种情况下，有些人能够写一个显示角色实时环境的雷达机器人，有很大的策略势。
    最后，你有一个在某些区有权威的client,比如角色移动。在这种情况下，玩家在有合适修改的client的情况下，能够向server返回奇怪的值，为他获得飞或者不可思议的跑的速度。这对于在线游戏很严重，因为在线游戏强调游戏平衡和感知平衡。理想情况下，不允许client管理任何东西就可以解决，但是有时这样做不现实。
    如果玩家通过一个破解的client作弊，即client被修改，可以采取检测可执行文件的校验和(checksum)来解决。这是一个失败的命题-如果有人有Soft-ICE或者类似的调试器链接到你的程序，在长期来看，要失败的。稍微容易处理的是当某人安装一个代理，或者一个程序截取server与client之间的网络流量.代理依赖于知道client和server之间发送的包的格式和内容,如果你能去掉这些信息，你能达到一些防破解的目的。
   意味着加密。   
加密
  加密server与client之间的数据尤其重要，不只是为了避免作弊，为了基本的安全。比如，一个玩家以纯文本明文形式发送信用卡号及密码，有人使用一个简单的包嗅探器就能够全部读取信息。
   即便忽略隐私问题，也有作弊的问题。明文包很容易被检测和逆向工程，所以阻止通过代理/嗅探的作弊方法，加密是重要的方法。
  基于以上原因，我们需要关注两种主要的加密形式---对称式加密(symmetric key encryption)
和非对称式加密(assymetric key encryption)
   对称式加密工作原理：client与server共用单个key.大部分对称加密算法，如Blowfish,比非对称加密算法快几个数量级。
   非对称加密不共享key。每个团体有一个key用来加密和解密信息。拥有一个key不允许解密用同样key加密的消息。非对称算法如PGP和RSA非常耗费资源不适合包加密。
   理想化情况是每个信息都使用对称算法加密，但是会出现一个严重的问题---如何安全地交换key?
 一种机制是生成key基于client和server都知道的client数据，如client的名称和地址。双方都可以生成一个完全对称的key在不用明文交换信息的情况下。
   当避免包嗅探时，这种方法管用。但是不能阻止有人直接破解client，找到key值，之后把key值存储在代理中，这种方法也能解密包流(packet stream)。另外，这需要server需要先验地知道client细节的信息，对于那些非持久不需要注册的游戏这种方法不太好。
  这就是非对称算法起作用的地方。在非对称系统中，server有一个private key和一个public key.公钥所有client都知道。client随机生成一个per-session对称加密key,用server的public
key 进行加密，然后发送。
  当包到达时，server用private key解密，然后获得session key，之后开始发送数据lkgcclient 使用对称加密算法。
  这样提供了一个安全与性能的平衡。理论上session key依然能够被获得，但需要一个活动的破解client而不仅仅是破解client(或者它的数据文件)和存储key一次。这样并非完全安全，
但是大大提高了破解的难度。  
多平台问题
  当与网络多玩家游戏打交道时，有可能需要你在不同的系统(heterogenous systems)之间交换信息。比如，你的server在Sparc/Solaris上运行，但是你的client在x86/Windows上。
正如将数据持久化到硬盘，你要意识到大小，大小端(endianess)和对齐(alignment)问题当将数据持久化到网络。另外，记得有些问题，比如浮点数，可能值不相等在不同的系统不同的处理器或者client用不同的编译器编译。
大小端在网络通信()作用重大，有用来处理从“网络”端(大端)到主机端的库函数。有以下函数：
 ntohl() – network-to-host byte ordering,long(32-bits)
ntohs() – network-to-host byte ordering,short(16-bits)
htonl() – host-to-network byte ordering,long(32-bits)
ntons() – host-to-network byte ordering, short(16-bits)
更安全的解决办法，建议在更高的层面处理端问题，使用自定义宏/函数。另外，你可以查看POSH头。

总结：
  多玩家网络游戏编程异常复杂且令人望而却步，源于仅学一小部分就很困难。在起初被认为是不可能完成的任务，有太多的不相关的问题没有一个对全局情形的理解。
   此文档目的是从不同的方面网络游戏环境各个不同的模块是如何组合在一起的提供一个更高的视角。虽然没有提供实际的源码，谈不上成功与失败。最重要的是理解关键点，因为代码会根据你的设计标准的不同而变化。
贡献者
推荐读物
  Stevens, W. Richard, “UNIX Network Programming, Vol.1”, Pearson Education.

